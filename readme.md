# Overview

The system works by translating user input into control signals that does whatever the option selected says. To run through the entire process, a picoblaze assembly file was created where a menu is printed out to the user. This menu has a list of several options such as “record”,  “playback”,  and “delete.” The picoblaze program will hang in a loop waiting for user input from the uart rx to select an option, the options being an asci 1, 2, 3, etc. that corresponds to the printed menu options. After an option is selected, the picoblaze program does a switch statement on the ascii input to determine what signals should be sent to the FSM. In our system, all FSM signals are output to specifically one port of picoblaze, port 06. Our FSM constantly checked (100mhz clock) if our write strobe is high and if the port ID is port 06. If both cases are true, our signals are assigned according to the actual output of picoblaze. For example, port ID of 06 and output of 00 corresponded to a “playback” state, while an output of 01 corresponded to a “record” state. This was done for all the signals we used for our system (play, record, delete, and pause). Most options from the picbolaze have submenus as well. For example, while in the playback submenu, the existing options are “stop” (to stop playing back) and “pause/play” (which will pause or play if the current track is paused.)   With a way for signals to be sent to our FSM, we were then able to create the proper connections between our FSM, RAM,  and codec interface. Our FSM starts out in a case state where it loops until a signal such as “record” or “play” is generated by picoblaze. To give an overview of one signal (read code for info on all others), let us look what happens when a user tries to record. If a signal such as record is activated, then the FSM would first start a 300 cycle delay (this is our sampling rate delay since we don’t want to take a sample every cycle at 37.5 mhz , otherwise we’d fill our entire memory in less than a second). After that, we ensure that we are still in the recording state, as picoblaze could have initialized different signals in that large time. We take the output of our codec interface (where we have our 16bit data from a sample) and write it our data_in of RAM. We initialize our write strobe next state, then set it low in the following state. We increment the address in this state then loop back to the start of the recording state. This project is currently equipped to only record/play 1 track.